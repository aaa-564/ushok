Юшков Артём УИБО-13-24
	
Алгоритмы сортировки
	
Сортировка выбором (Selection Sort)	
Определение: на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве
Анализ алгоритма:

• Выбор минимального элемента: на каждом этапе ищется минимальный элемент из всех последующих позиций массива
• Замена местоположением: Минимальный элемент меняется местами с текущим элементом, обеспечивая постепенное формирование отсортированного начала массива
• Повторение процесса: Эта процедура повторяется для каждого элемента, пока весь массив не будет отсортирован

Временная сложность O(n²): объяснение
•	Внешний цикл: проходит по каждому элементу массива, кроме последнего, что даёт n-1 итераций.
•	Внутренний цикл: на каждой итерации внешнего цикла проходит по оставшимся элементам, что даёт в сумме n(n-1)/2 сравнений.
•	Обмен местами: Каждый обмен требует константного времени, что не влияет на общую сложность.


##Сортировка обменом (пузырьком) (Bubble Sort)
Определение: алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.

Анализ алгоритма:
o	Проход по массиву: последовательное сравнение соседних элементов слева направо
o	Сравнение и обмен: если левый элемент больше правого – выполняется обмен
o	Всплытие максимумов: за каждую итерацию наибольший элемент перемещается в конец массива
o	Уменьшение области: с каждой итерацией обрабатывается меньшая часть массива
o	Завершение: процесс повторяется до полной сортировки массива

Временная сложность O(n²): O(n²) — массив отсортирован в обратном порядке, требуется ~n×(n-1)/2 сравнений и обменов, так как алгоритм использует два вложенных цикла


##Сортировка вставками (Insertion Sort)
Определение: алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.

Анализ алгоритма:
o	Обработка n-1 элементов: последовательная обработка каждого элемента с индексами от 1 до n-1
o	Поиск позиции: сравнение текущего элемента с предыдущими в отсортированной части (до 0)
o	Сдвиг элементов: сдвиг всех элементов > key на 1 позицию вправо (до i сдвигов)
o	Вставка: помещение элемента на найденную позицию j+1 после сдвига

Временная сложность O(n²): O(n²) — массив отсортирован в обратном порядке, требуется n×(n-1)/2 операций (сравнений и сдвигов)



##Сортировка слиянием (Merge Sort)
Определение: алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.
Анализ алгоритма:
o	Разбиение массива: Массив рекурсивно делится пополам до тех пор, пока каждая часть не станет содержать всего один элемент.
o	Базовый случай: Одинарные элементы рассматриваются как уже отсортированные.
o	Слияние частей: Отсортированные части объединяются таким образом, чтобы результирующий массив оставался отсортированным.
o	Рекурсия и объединение: Эти этапы выполняются до тех пор, пока весь массив снова не соберётся вместе в отсортированном виде.

Временная сложность O(n log n): объяснение
o	Массив делится пополам на log n уровней рекурсии, где на каждом уровне выполняется слияние всех n элементов за O(n) операций
o	Итого: log n × O(n) = O(n log n).



##Сортировка Шелла (Shellsort)
Определение: является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.
Анализ алгоритма:
o устанавливает: начальный промежуток (gap), постепенно уменьшающийся.
o частично сортирует элементы: находящиеся на расстоянии gap.
o завершается: обычной сортировкой вставками при gap = 1.

Временная сложность O(n log² n), O(n²) или O(n): объяснение
o	O(n log²n) в среднем случае для оптимальных последовательностей шагов (gaps)
o	Сложность зависит от выбора шагов — внутренние циклы выполняются меньше операций благодаря частичной сортировке элементов на расстоянии.



##Быстрая сортировка (Quick Sort)
Определение: один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них
Анализ алгоритма:
o	Выбор опорного элемента: выбор одного из n элементов массива в качестве разделителя
o	Разделение на подмассивы: создание двух частей - с элементами меньше и больше разделителя
o	Рекурсивная обработка: повторение алгоритма для обеих частей до их полной сортировки
o	Базовый случай: массивы из 0 или 1 элемента считаются отсортированными

Временная сложность O(n log n) или O(n²): объяснение
o	O(n log n) в среднем и лучшем случае при сбалансированном разделении
o	O(n²) в худшем случае при выборе крайних элементов как опорных
o	Сложность определяется глубиной рекурсии (log n при удачном разделении, n при неудачном) и количеством операций сравнения на каждом уровне.



##Пирамидальная сортировка
Определение: алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.
Анализ алгоритма:
o	Создание Max-Heap: Преобразуем массив в двоичную пирамиду (max-heap), где родительские узлы всегда больше детей.
o	Удаление корней: Удаляем корень (самый большой элемент) и добавляем его в конец массива, после чего повторно формируем пирамиду.
o	Повторение: Повторяем второй пункт, пока все элементы не перейдут в отсортированное состояние.

Временная сложность O(n log n): объяснение
o	O(n log n) — построение бинарной кучи выполняется за O(n), а n операций извлечения корня с восстановлением структуры требуют O(log n) каждая, что в сумме дает O(n log n).





Алгоритмы поиска
##Последовательный (линейный) поиск
Определение: простейший алгоритм поиска, осуществляемый путем последовательного сравнения каждого элемента с искомым значением до их совпадения. Временная сложность составляет O(n), что делает метод неэффективным для больших данных, однако он прост в реализации и применим для небольших или неотсортированных наборов.
Анализ алгоритма:
o	Последовательный просмотр: Алгоритм последовательно просматривает элементы массива, начиная с первого.
o	Проверка совпадения: Каждый элемент сравнивается с искомым значением.
o	Возврат результата: Если элемент найден, возвращается его индекс; иначе возвращаем специальный маркер (-1), означающий отсутствие элемента

Временная сложность O(n), O(n/2) ≈ O(n) или O(1): объяснение
o	Худший случай: O(n) — элемент находится в конце массива или отсутствует, нужно проверить все n элементов
o	Средний случай: O(n/2) ≈ O(n)




##Бинарный (двоичный, дихотомический) поиск
Определение: алгоритм поиска на упорядоченном множестве путём многократного деления его на две части, в одной из которых должен находиться искомый элемент. Поиск завершается при нахождении элемента или проверке всех частей. Преимущество — низкая трудоёмкость (O(log n)), недостаток — требование отсортированности данных.
Анализ алгоритма:
o	Начальная установка границ: Устанавливаем левую границу (left) равной началу массива, а правую (right) — концу массива.
o	Нахождение середины: Рассчитываем индекс центрального элемента массива (mid), используя формулу (left + right) / 2.
o	Сравнение: Сравниваем центральный элемент (arr[mid]) с искомым значением (target):
	Если центральное значение равно цели, возвращаем его индекс.
	Если оно больше цели, обновляем правую границу (right = mid - 1), сужая область поиска влево.
	Если оно меньше цели, обновляем левую границу (left = mid + 1), смещая область поиска вправо.
o	Продолжение поиска: Повторяем процесс, пока границы не пересекутся (left > right), если цель не была найдена, возвращаем индикатор неудачи (-1)

Временная сложность O(log n): объяснение
o	O(log n), так как на каждом шаге алгоритм уменьшает область поиска вдвое путем сравнения целевого значения со средним элементом, что требует не более log₂n итераций для нахождения элемента в отсортированном массиве.



##Интерполирующий поиск
Определение: это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно.
Анализ алгоритма:
o	Вычисление позиции: Используется формула интерполяции для оценки возможной позиции искомого элемента.
o	Сравнение: Находится ближайший элемент и сравнивается с целью.
o	Рекурсия: Если элемент не найден сразу, выполняется рекурсивный поиск либо в левой, либо в правой части массива.
o	Возвращение результата: Если элемент найден, возвращается его индекс, иначе — сигнализируется ошибка (-1).

Временная сложность O(log log n) или O(n): объяснение
o	O(log log n) в среднем случае при равномерном распределении данных благодаря предсказанию позиции элемента через интерполяционную формулу
o	O(n) в худшем случае при неравномерном распределении, когда алгоритм вырождается в линейный поиск.

##Поиск по Фибоначчи
Определение: это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения.
Анализ алгоритма:
o	Подготовка: нахождение ближайшего числа Фибоначчи Fₖ ≥ n
o	Расчёт границ: определение индексов через числа Фибоначчи Fₖ₋₁, Fₖ₋₂
o	Сравнение:
	элемент < цели → смещение вправо (Fₖ₋₂)
	элемент > цели → смещение влево (Fₖ₋₁)
o	Сужение области: после каждой проверки окно поиска уменьшается
o	Завершение: процесс продолжается пока Fₖ > 1 или элемент не найден

Временная сложность O(log n): объяснение
o	O(log n), так как алгоритм использует числа Фибоначчи для определения точек разбиения массива, и каждая итерация сокращает область поиска через переход к меньшим числам Фибоначчи, что требует примерно log n операций.




