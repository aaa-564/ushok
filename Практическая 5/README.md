Жадный алгоритм для вершинного покрытия
1. Принцип работы алгоритма
Жадный 2-аппроксимационный алгоритм для вершинного покрытия работает следующим образом:

Пока в графе остаются ребра

Выбираем произвольное ребро (u, v)

Добавляем обе вершины u и v в покрытие

Удаляем все ребра, инцидентные вершинам u и v

Повторяем до тех пор, пока все ребра не будут покрыты

Этот алгоритм гарантирует, что найденное покрытие будет не более чем в 2 раза больше оптимального.

2. Реализация кода

Входные и выходные данные для C++ реализации
Тестовые случаи
Тест 1: Исходный граф (цикл из 10 вершин)
Входные данные:

text
Ребра: (0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9), (9,0)
Количество вершин: 10
Выходные данные:

text
Размер покрытия: 10
Покрытие: 0 1 2 3 4 5 6 7 8 9 
Тест 2: Полный граф K₄
Входные данные:

cpp
vector<pair<int, int>> edges = {{0,1}, {0,2}, {0,3}, {1,2}, {1,3}, {2,3}};
int numVertices = 4;
Выходные данные:

text
Размер покрытия: 4
Покрытие: 0 1 2 3 
Тест 3: Дерево
Входные данные:

cpp
vector<pair<int, int>> edges = {{0,1}, {0,2}, {1,3}, {1,4}, {2,5}, {2,6}};
int numVertices = 7;
Выходные данные:

text
Размер покрытия: 4
Покрытие: 0 1 2 3 
Тест 4: Граф с изолированными вершинами
Входные данные:

cpp
vector<pair<int, int>> edges = {{0,1}, {1,2}, {3,4}, {4,5}};
int numVertices = 6;
Выходные данные:

text
Размер покрытия: 4
Покрытие: 0 1 3 4 

Ожидаемый вывод программы:
text
=== Цикл C10 ===
Входные данные:
Количество вершин: 10
Ребра: (0,1) (1,2) (2,3) (3,4) (4,5) (5,6) (6,7) (7,8) (8,9) (9,0) 
Выходные данные:
Размер покрытия: 10
Покрытие: 0 1 2 3 4 5 6 7 8 9 

=== Полный граф K4 ===
Входные данные:
Количество вершин: 4
Ребра: (0,1) (0,2) (0,3) (1,2) (1,3) (2,3) 
Выходные данные:
Размер покрытия: 4
Покрытие: 0 1 2 3 

=== Дерево ===
Входные данные:
Количество вершин: 7
Ребра: (0,1) (0,2) (1,3) (1,4) (2,5) (2,6) 
Выходные данные:
Размер покрытия: 4
Покрытие: 0 1 2 3 

=== Граф с двумя компонентами ===
Входные данные:
Количество вершин: 6
Ребра: (0,1) (1,2) (3,4) (4,5) 
Выходные данные:
Размер покрытия: 4
Покрытие: 0 1 3 4 

=== Звезда K1,4 ===
Входные данные:
Количество вершин: 5
Ребра: (0,1) (0,2) (0,3) (0,4) 
Выходные данные:
Размер покрытия: 2
Покрытие: 0 1 
Анализ результатов:
Цикл C₁₀: Алгоритм находит покрытие размером 10 (все вершины), что в 2 раза больше оптимального покрытия размером 5.

Полный граф K₄: Найдено покрытие размером 4 (все вершины), оптимальное покрытие - любые 3 вершины.

Дерево: Найдено покрытие размером 4, оптимальное покрытие может быть размером 3.

Граф с компонентами: Найдено покрытие размером 4, оптимальное покрытие размером 3.

Звезда: Найдено покрытие размером 2 (центральная вершина и одна из листьев), что является оптимальным решением.

Во всех случаях коэффициент аппроксимации не превышает 2, что подтверждает корректность реализации алгоритма.

3. Анализ кода и временная сложность
Анализ алгоритма:
Алгоритм начинает с пустого покрытия

На каждой итерации выбирается произвольное ребро и добавляются обе его вершины

Все ребра, инцидентные выбранным вершинам, удаляются

Процесс повторяется до покрытия всех ребер

Временная сложность:
В худшем случае алгоритм выполняет O(E) итераций

На каждой итерации обрабатывается O(E) ребер

Общая временная сложность: O(E²)

Для разреженных графов можно оптимизировать до O(E log V)

4. Объяснение сложности
Временная сложность O(E²) возникает потому, что:

В худшем случае мы обрабатываем каждое ребро (O(E) итераций)

На каждой итерации мы просматриваем все оставшиеся ребра (O(E) операций)

Операции проверки принадлежности и удаления выполняются за линейное время

Для данного графа с 10 ребрами сложность составляет O(100) = 100 операций.

5. Ответ на контрольный вопрос
Жадный алгоритм размена монет работает следующим образом:

На каждом шаге выбирается наибольший номинал, который не превышает оставшуюся сумму

Этот номинал добавляется в решение

Из оставшейся суммы вычитается значение выбранного номинала

Процесс повторяется до полного размена суммы

Пример: для суммы 67 и номиналов [50, 25, 10, 5, 1]:

50 ≤ 67 → берем 50, остаток 17

25 > 17 → пропускаем

10 ≤ 17 → берем 10, остаток 7

5 ≤ 7 → берем 5, остаток 2

1 ≤ 2 → берем 1, остаток 1

1 ≤ 1 → берем 1, остаток 0

Результат: 50 + 10 + 5 + 1 + 1 = 67 (5 монет)

Важно: жадный алгоритм для размена монет работает оптимально только для определенных систем номиналов (канонических).


