## Юшков Артём УИБО-13-24

## Анализ кучи

Бинарная куча формируется как полное бинарное дерево, хранимое в массиве, где оператор индексации реализует доступ к родительским и дочерним узлам через арифметику индексов: для узла с индексом ii левый потомок имеет индекс 2i+12i+1, правый — 2i+22i+2, а родитель — ⌊(i−1)/2⌋⌊(i−1)/2⌋. Это позволяет эффективно поддерживать свойство кучи (min- или max-heap) через операции вставки (добавление в конец с последующим "подъемом" — heapifyUp) и извлечения минимума/максимума (замена корня последним элементом и "спуск" — heapifyDown). В Python для этого используется модуль heapq, в C++ — ручная реализация на основе std::vector с шаблонными методами heapifyUp/Down, а в Java — класс PriorityQueue или собственная реализация на массиве с поддержкой обобщенных типов через интерфейс Comparable. Биномиальная куча организуется как набор биномиальных деревьев различного порядка, где каждое дерево порядка kk содержит 2k2k узлов. Операция слияния куч реализуется аналогично сложению двоичных чисел — объединением деревьев одинакового порядка. В C++ это достигается через указатели и рекурсивное слияние списков корней, в Java — через циклические ссылки между узлами, а в Python стандартной реализации нет, что требует ручного описания структуры. Куча Фибоначчи, как более общая и эффективная для ряда операций, строится на наборе деревьев с поддержкой ленивого слияния и отложенной консолидации. Операции уменьшения ключа и удаления могут приводить к вырезанию поддеревьев и каскадному сокращению (cascading cut). В C++ и Java её реализация основана на двусвязных циклических списках и поддержке пометок (mark) для узлов, что позволяет достичь амортизировано O(1)O(1) для вставки и уменьшения ключа.

## Анализ хэш-таблицы

Хеш-таблица представляет собой структуру данных для хранения пар «ключ-значение» с быстрым доступом. Её формирование основано на использовании хеш-функции, которая преобразует ключ в индекс массива (бакета). В Python хеш-таблицы реализованы через встроенный тип dict, использующий открытую адресацию и двойное хеширование для разрешения коллизий. В C++ стандартная библиотека предлагает контейнер std::unordered_map, в основе которого лежит метод цепочек — каждый бакет содержит связный список пар. Также возможна ручная реализация на массиве списков с использованием шаблонов и std::hash. В Java хеш-таблицы представлены классами HashMap и Hashtable, где HashMap (на основе массива и цепочек) является более современным аналогом, а Hashtable — синхронизированной версией. Во всех случаях ключевым этапом формирования является инициализация массива бакетов, определение хеш-функции и выбор стратегии разрешения коллизий (цепочки, открытая адресация), что напрямую влияет на производительность операций вставки, поиска и удаления.
