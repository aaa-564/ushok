##Юшков Артём УИБО-13-24
##Анализ кучи
Бинарная куча формируется как полное бинарное дерево, хранимое в массиве, где оператор индексации реализует доступ к родительским и дочерним узлам через арифметику индексов: для узла с индексом ii левый потомок имеет индекс 2i+12i+1, правый — 2i+22i+2, а родитель — ⌊(i−1)/2⌋⌊(i−1)/2⌋. Это позволяет эффективно поддерживать свойство кучи (min- или max-heap) через операции вставки (добавление в конец с последующим "подъемом" — heapifyUp) и извлечения минимума/максимума (замена корня последним элементом и "спуск" — heapifyDown). В Python для этого используется модуль heapq, в C++ — ручная реализация на основе std::vector с шаблонными методами heapifyUp/Down, а в Java — класс PriorityQueue или собственная реализация на массиве с поддержкой обобщенных типов через интерфейс Comparable. Биномиальная куча организуется как набор биномиальных деревьев различного порядка, где каждое дерево порядка kk содержит 2k2k узлов. Операция слияния куч реализуется аналогично сложению двоичных чисел — объединением деревьев одинакового порядка. В C++ это достигается через указатели и рекурсивное слияние списков корней, в Java — через циклические ссылки между узлами, а в Python стандартной реализации нет, что требует ручного описания структуры. Куча Фибоначчи, как более общая и эффективная для ряда операций, строится на наборе деревьев с поддержкой ленивого слияния и отложенной консолидации. Операции уменьшения ключа и удаления могут приводить к вырезанию поддеревьев и каскадному сокращению (cascading cut). В C++ и Java её реализация основана на двусвязных циклических списках и поддержке пометок (mark) для узлов, что позволяет достичь амортизировано O(1)O(1) для вставки и уменьшения ключа.
